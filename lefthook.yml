# Lefthook configuration for segnomms
# See https://github.com/evilmartians/lefthook for more information

commit-msg:
  commands:
    conventional-commits:
      run: ./repo/validate_conventional_commits.sh --commit-msg="{1}" --local-mode

pre-commit:
  # Run sequentially to avoid concurrent 'git add' (index.lock) when stage_fixed is used
  parallel: false
  commands:
    # GitHub Actions linting
    actionlint:
      glob: ".github/workflows/*.{yml,yaml}"
      run: actionlint {staged_files}
    validate-gha-event-fixtures:
      # Only run when event/test JSON files changed
      glob: "repo/gha/{events,tests}/**/*.json"
      # Lefthook expands {staged_files} to the matching staged files
      run: node repo/gha/scripts/validate-event-payloads.mjs --format {staged_files}
      # If the script reformats JSON, auto re-stage fixes
      stage_fixed: true
    # Python code formatting - Black
    black:
      glob: "*.py"
      run: black {staged_files}
      stage_fixed: true
    # Python import sorting - isort
    isort:
      glob: "*.py"
      run: isort --profile black {staged_files}
      stage_fixed: true
    # Python linting - Flake8
    flake8:
      glob: "*.py"
      exclude: "examples/**/*.py"
      # F841: Unused variables (Priority 1) - STRATEGIC (enhanced with validation assertions)
      run: flake8 --extend-ignore=F841 {staged_files}

    # General file fixes - run BEFORE validation hooks
    trailing-whitespace:
      run: python -m pre_commit_hooks.trailing_whitespace_fixer {staged_files} || true
      stage_fixed: true

    end-of-file:
      run: python -m pre_commit_hooks.end_of_file_fixer {staged_files} || true
      stage_fixed: true

    # Validation hooks - run AFTER file fixes
    # Note: check-merge-conflict removed - git prevents commits with conflict markers anyway

    check-yaml:
      glob: "*.{yml,yaml}"
      exclude: ".github/workflows/*.{yml,yaml}"
      run: |
        for file in {staged_files}; do
          python -c "import yaml; yaml.safe_load(open('$file'))" || exit 1
        done

    check-json:
      glob: "*.json"
      run: |
        for file in {staged_files}; do
          python -m json.tool "$file" > /dev/null || exit 1
        done

    debug-statements:
      glob: "*.py"
      run: |
        for file in {staged_files}; do
          if grep -E '(import pdb|pdb\.set_trace\(\)|import ipdb|ipdb\.set_trace\(\))' "$file"; then
            echo "Debug statements found in $file"
            exit 1
          fi
        done

    # Type checking - MyPy with comprehensive configuration from pyproject.toml
    mypy:
      glob: "*.py"
      exclude: "tests/|examples/|repo/"
      run: mypy {staged_files}

    # Security scanning with bandit
    bandit:
      glob: "*.py"
      exclude: "tests/|examples/|repo/"
      run: bandit -c .bandit -r {staged_files}

    # Repository scripts should trigger when changed
    repo-scripts:
      glob: "repo/*.py"
      run: |
        echo "Repository script changed: {staged_files}"
        echo "Consider running relevant tests if scripts are modified"

    # Documentation dependency check (for docs changes)
    doc-dependencies:
      glob: "docs/**/*.{rst,md,py}"
      run: python repo/check_doc_dependencies.py

    # Documentation build test (optional - can be skipped with LEFTHOOK_EXCLUDE)
    doc-build:
      glob: "docs/**/*.{rst,md,py}"
      run: python repo/check_doc_build.py --skip-if-missing-deps --quiet

    # Documentation reference validation (validates cross-references, toctrees, API refs)
    doc-references:
      glob: "docs/**/*.rst"
      run: python repo/validate_docs_references.py

    # Documentation spell checking with cspell (optional - can be skipped with LEFTHOOK_EXCLUDE)
    spell-check:
      glob: "docs/**/*.{rst,md}"
      run: |
        # Install cspell if needed
        if ! command -v npx &> /dev/null || ! npx cspell --version &> /dev/null 2>&1; then
          echo "Installing cspell (Code Spell Checker)..."
          ./repo/setup_cspell.sh
        fi
        # Run spell check on documentation files
        python repo/spell_check_docs_cspell.py --files {staged_files} --quiet

    # Project dictionary changes should trigger spell check
    spell-check-dict:
      glob: "project-words.txt"
      run: |
        echo "Project dictionary updated - running full spell check"
        if ! command -v npx &> /dev/null || ! npx cspell --version &> /dev/null 2>&1; then
          echo "Installing cspell (Code Spell Checker)..."
          ./repo/setup_cspell.sh
        fi
        python repo/spell_check_docs_cspell.py --quiet

    # cspell configuration changes should trigger spell check
    spell-check-config:
      glob: "cspell.json"
      run: |
        echo "cspell configuration updated - running full spell check"
        if ! command -v npx &> /dev/null || ! npx cspell --version &> /dev/null 2>&1; then
          echo "Installing cspell (Code Spell Checker)..."
          ./repo/setup_cspell.sh
        fi
        python repo/spell_check_docs_cspell.py --quiet

    # Spec-kit validation for specification files
    spec-kit-validation:
      glob: "specs/**/*.md"
      run: |
        echo "Specification files changed - validating..."
        # Check markdown syntax
        for file in {staged_files}; do
          if [[ "$file" == *.md ]]; then
            python -c "import markdown; markdown.markdown(open('$file').read())" 2>/dev/null || {
              echo "❌ Markdown syntax error in $file"
              exit 1
            }
          fi
        done
        echo "✅ Specification files validated"

    # Spec-kit constitution validation
    spec-kit-constitution:
      glob: ".specify/memory/constitution.md"
      run: |
        echo "Constitution updated - validating format..."
        # Check for required sections and version format
        file="{staged_files}"
        if ! grep -q "^## Core Principles" "$file"; then
          echo "❌ Constitution missing 'Core Principles' section"
          exit 1
        fi
        if ! grep -q "^## Governance" "$file"; then
          echo "❌ Constitution missing 'Governance' section"
          exit 1
        fi
        if ! grep -qE "^\*\*Version\*\*: [0-9]+\.[0-9]+\.[0-9]+" "$file"; then
          echo "❌ Constitution missing valid version format (x.y.z)"
          exit 1
        fi
        echo "✅ Constitution format validated"

    # Spec-kit template consistency check
    spec-kit-templates:
      glob: ".specify/templates/*.md"
      run: |
        echo "Spec-kit templates changed - checking for placeholder consistency..."
        for file in {staged_files}; do
          # Check for unresolved placeholders (basic validation)
          if grep -q '\[.*_.*\]' "$file" && ! grep -q '<!-- Example:' "$file"; then
            echo "⚠️  Template $file may contain unresolved placeholders"
          fi
        done
        echo "✅ Template consistency checked"
